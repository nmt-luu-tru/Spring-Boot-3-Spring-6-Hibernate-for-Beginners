### Xử Lý Ngoại Lệ Trong Spring REST (Exception Handling)

#### 1. **Giới thiệu về Xử Lý Ngoại Lệ Trong Spring REST**
Trong video này, chúng ta sẽ học cách **xử lý ngoại lệ trong Spring REST**. Trong các video trước, chúng ta đã gặp phải vấn đề khi nhập một `studentId` không hợp lệ, ví dụ như **999**, dẫn đến việc nhận một thông báo lỗi **500 Internal Server Error**. Lỗi này là do **IndexOutOfBoundsException**, và chúng ta muốn xử lý nó một cách "thân thiện" hơn với người dùng.

Mục tiêu của chúng ta là:
- **Xử lý ngoại lệ** thay vì trả về thông báo lỗi HTML xấu xí.
- **Trả về JSON** có thông tin về lỗi, bao gồm **mã trạng thái**, **thông điệp lỗi**, và **thời gian lỗi xảy ra**.

#### 2. **Quy Trình Phát Triển Xử Lý Ngoại Lệ**
Để triển khai giải pháp xử lý ngoại lệ cho REST API, chúng ta sẽ thực hiện các bước sau:

1. **Tạo lớp phản hồi lỗi tùy chỉnh (Custom Error Response Class)**.
2. **Tạo ngoại lệ tùy chỉnh (Custom Exception Class)**.
3. **Cập nhật REST Service để ném ngoại lệ khi không tìm thấy sinh viên**.
4. **Thêm phương thức xử lý ngoại lệ bằng @ExceptionHandler**.

##### **Bước 1: Tạo Lớp Phản Hồi Lỗi Tùy Chỉnh (Custom Error Response Class)**
Chúng ta cần tạo một lớp tùy chỉnh để chứa thông tin phản hồi khi có lỗi xảy ra. Lớp này sẽ được chuyển đổi thành JSON và trả về cho client khi có ngoại lệ. Chúng ta sẽ gọi lớp này là **StudentErrorResponse** và định nghĩa các trường thông tin như sau:
- **status**: Mã trạng thái HTTP (ví dụ: 404).
- **message**: Thông điệp lỗi để giải thích vấn đề.
- **timeStamp**: Thời điểm xảy ra lỗi.

Mã cho lớp **StudentErrorResponse** như sau:

```java
public class StudentErrorResponse {
    private int status;
    private String message;
    private long timeStamp;

    public StudentErrorResponse() {}

    public StudentErrorResponse(int status, String message, long timeStamp) {
        this.status = status;
        this.message = message;
        this.timeStamp = timeStamp;
    }

    // Getters and Setters
}
```

**Jackson** sẽ chịu trách nhiệm chuyển đổi đối tượng này thành JSON để trả về cho client.

##### **Bước 2: Tạo Ngoại Lệ Tùy Chỉnh (Custom Exception Class)**
Tiếp theo, chúng ta sẽ tạo một ngoại lệ tùy chỉnh để sử dụng trong REST service. Ngoại lệ này sẽ được ném khi không tìm thấy sinh viên với `studentId` mà người dùng cung cấp. Lớp này sẽ kế thừa từ **RuntimeException**.

Mã cho lớp **StudentNotFoundException** như sau:

```java
public class StudentNotFoundException extends RuntimeException {
    public StudentNotFoundException(String message) {
        super(message);
    }
}
```

##### **Bước 3: Cập Nhật REST Service Để Ném Ngoại Lệ Khi Không Tìm Thấy Sinh Viên**
Chúng ta sẽ cập nhật phương thức `getStudent()` trong lớp **StudentRestController** để ném ngoại lệ **StudentNotFoundException** khi không tìm thấy `studentId`.

```java
@GetMapping("/students/{studentId}")
public Student getStudent(@PathVariable int studentId) {
    if (studentId >= students.size() || studentId < 0) {
        throw new StudentNotFoundException("Student id not found - " + studentId);
    }
    return students.get(studentId);
}
```

- **Điều kiện kiểm tra**: Nếu `studentId` lớn hơn hoặc bằng kích thước danh sách sinh viên, hoặc nhỏ hơn 0, chúng ta ném ngoại lệ **StudentNotFoundException**.
- **Ném ngoại lệ**: Sử dụng từ khóa `throw` để ném ngoại lệ cùng với thông điệp lỗi.

##### **Bước 4: Thêm Phương Thức Xử Lý Ngoại Lệ Bằng @ExceptionHandler**
Chúng ta sẽ sử dụng **@ExceptionHandler** để định nghĩa phương thức xử lý ngoại lệ. Phương thức này sẽ trả về một đối tượng **ResponseEntity** chứa thông tin lỗi dưới dạng JSON. Chúng ta cũng sẽ sử dụng **@ControllerAdvice** để có thể xử lý ngoại lệ toàn cục.

Ví dụ về xử lý ngoại lệ:

```java
@ControllerAdvice
public class StudentRestExceptionHandler {

    // Exception handler for StudentNotFoundException
    @ExceptionHandler
    public ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException exc) {
        // Tạo đối tượng phản hồi lỗi
        StudentErrorResponse error = new StudentErrorResponse(
            HttpStatus.NOT_FOUND.value(), // Status code 404
            exc.getMessage(),              // Thông điệp lỗi từ ngoại lệ
            System.currentTimeMillis()     // Thời điểm lỗi xảy ra
        );

        // Trả về ResponseEntity với đối tượng lỗi và mã trạng thái 404
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    // Generic exception handler cho các ngoại lệ khác
    @ExceptionHandler
    public ResponseEntity<StudentErrorResponse> handleException(Exception exc) {
        StudentErrorResponse error = new StudentErrorResponse(
            HttpStatus.BAD_REQUEST.value(), // Status code 400
            "Invalid request",              // Thông điệp lỗi tùy chỉnh
            System.currentTimeMillis()      // Thời điểm lỗi xảy ra
        );

        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
}
```

**Giải thích chi tiết Exception Handler**:
- **@ControllerAdvice**: Được sử dụng để định nghĩa một lớp xử lý ngoại lệ toàn cục cho tất cả các controller. Điều này giúp chúng ta tránh việc phải xử lý ngoại lệ trong từng controller riêng lẻ.
- **@ExceptionHandler**: Đánh dấu phương thức này là phương thức xử lý cho ngoại lệ cụ thể. Trong ví dụ này, có hai phương thức xử lý:
  - Phương thức đầu tiên xử lý **StudentNotFoundException** và trả về thông tin chi tiết về lỗi (mã trạng thái 404, thông điệp lỗi, và thời điểm lỗi).
  - Phương thức thứ hai xử lý các ngoại lệ chung (ví dụ như **IllegalArgumentException** hoặc **NumberFormatException**) và trả về phản hồi với mã trạng thái **400 Bad Request**.
- **ResponseEntity<StudentErrorResponse>**: Chứa phản hồi HTTP bao gồm nội dung phản hồi và mã trạng thái. Phản hồi là đối tượng **StudentErrorResponse** mà chúng ta đã tạo, chứa các trường thông tin về lỗi.

#### 3. **Kết Quả Khi Gặp Ngoại Lệ**
Nếu gửi yêu cầu với `studentId` không tồn tại, ví dụ `/api/students/999`, kết quả trả về sẽ là:

```json
{
    "status": 404,
    "message": "Student id not found - 999",
    "timeStamp": 1603431890000
}
```

Nếu nhập `studentId` không phải là số (ví dụ `/api/students/abc`), kết quả trả về sẽ là:

```json
{
    "status": 400,
    "message": "Invalid request",
    "timeStamp": 1603431890000
}
```

#### 4. **Thử Nghiệm Với Postman**
Chúng ta có thể sử dụng **Postman** để thử nghiệm các trường hợp:
- Gửi yêu cầu **GET** với `studentId` hợp lệ, ví dụ `/api/students/0`, và kiểm tra kết quả trả về sinh viên đầu tiên.
- Gửi yêu cầu **GET** với `studentId` không hợp lệ, ví dụ `/api/students/999`, và kiểm tra phản hồi lỗi với mã trạng thái **404**.
- Gửi yêu cầu **GET** với `studentId` là ký tự, ví dụ `/api/students/abc`, để kiểm tra phản hồi lỗi với mã trạng thái **400**.

#### 5. **Kết Luận**
Trong video này, chúng ta đã học cách xử lý ngoại lệ trong Spring REST để tạo ra phản hồi thân thiện và chi tiết hơn cho người dùng. Cụ thể, chúng ta đã:
- Tạo lớp **StudentErrorResponse** để chứa thông tin lỗi.
- Tạo ngoại lệ tùy chỉnh **StudentNotFoundException**.
- Cập nhật **REST service** để ném ngoại lệ khi không tìm thấy sinh viên.
- Thêm **@ExceptionHandler** để xử lý ngoại lệ và trả về phản hồi JSON.

Điều này giúp cải thiện trải nghiệm người dùng khi làm việc với REST API của chúng ta và giúp cung cấp thông tin rõ ràng hơn khi có lỗi xảy ra. Video tiếp theo sẽ tiếp tục giới thiệu về cách tối ưu hơn để xử lý các loại lỗi khác, bao gồm các trường hợp ngoại lệ phức tạp hơn.
